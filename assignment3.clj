;   Author: Cody Albert
;   Title: Assignment 3

;; 1.
"Write a function called sdsu-rotate which can rotate a
sequence in either direction. The function can return a
collection type of your choice. Here are some examples."

(defn sdsu-rotate
  [x s]
  (loop [e x
         j (vec s)
         r []]
    (if (== (count r) (count j))
      r
      (recur (inc e) j (conj r (anyIndex e j))))))

(defn anyIndex
   ;; Return bounded and unbounded indexes of a sequence
  [x s]
  (cond
     (>= x (count s)) (nth s (rem x (count s)))
     (and (>= x 0) (< x (count s))) (nth s x)
     :else (nth (reverse s) (rem (- -1 x) (count s)))))


(sdsu-rotate -4 [5 6 7])
(sdsu-rotate -8 {:1 "2" :3 "4" :0 "0"})
(sdsu-rotate 10 [1 2 3 4 5])



;; 2.
"If we list all the positive integers below 10 that are multiples of 2 or 5, we get 2, 4, 6, 8, 5.
The sum of these multiples is 25. Write a function sdsu-sum that takes three arguments.
The first two arguments are the numbers we will take the multiples of. The third argument
is the number we want the multiples to be less than. Sdsu-sum returns the sum of the
multiples of the two numbers less than the third argument. For example:
(sdsu-sum 2 5 10) returns 25"


(defn sdsu-sum
 [x y l]
   (loop [a 1
          b 1
          s (hash-set)]
     (if (< (* x a) l)
       (recur (+ a 1) b (conj s (* x a)))
       (if (< (* y b) l)
         (recur a (inc b) (conj s (* y b)))
         s))))

(sdsu-sum 2 5 10)



;; 3.
"A palindromic integer is an integer that reads the same both ways. For example, 101, 121,
12321 and 98989 are all palindromic integers. The largest palindromic integer made from
the product of two 2-digit numbers is 9009 = 91 Ã— 99. Write a function sdsu-palindome that
takes one argument, an integer. The integer indicates the number of digits we are interest-
ing in. So (sdsu-palindrome 2) returns the largest palindromic integer made from the prod-
uct of two 2-digit numbers and (sdsu-palindrome 3) returns the largest palindromic integer
made from the product of two 3-digit numbers."

(defn sdsu-palindrome
  [i]
  )



;; 4.
"The Fibonacci sequence is generated by adding the previous two terms in the sequence.
We will start the sequence with 1 and 2. So the first ten elements are 1, 2, 3, 5, 8, 13, 21,
34, 55, 89. Write a function sdsu-fibonacci-even that takes one argument N. The function
returns the sum of all the even-valued terms in the Fibonacci sequence that are less then
or equal to N."

(defn sdsu-fibonacci-even
  [N]
    (loop [N N
           e 1
           f 1
           s []]
      (if (<= f N)
        (if (odd? f)
          (recur N f (+ f e) s)
          (recur N f (+ f e) (conj s f)))
        (reduce + s))))


(sdsu-fibonacci-even 8)



;; 5.
(comment "DNA can be represented as a string containing the characters A, C, G and T. These letters
represent the four nucleobases adenine (A), cytosine (C), guanine (G), and thymine (T).
An example of a DNA string is "ATGCTTCAGAAAGGTCTTACG". Write a functions sdsu-
dna-count that takes one argument, a DNA string, and returns a map that indicate the num-
ber of times each of the four characters appears in the DNA string. So for example we have:
(sdsu-dna-count "ATGCTTC") returns {:A 1 :T 3 :G 1 :C 2}
(sdsu-dna-count "ATGCTTCAGAAAGGTCTTACG") returns {:A 6 :T 6 :G 5 :C 4}")

(defn sdsu-dna-count
  [DNA]
  (let [dna-frequency (frequencies DNA)
        dna-count {:A 0
                   :T 0
                   :G 0
                   :C 0}]
    (assoc
      (assoc
        (assoc
          (assoc dna-count :A (get dna-frequency \A))
          :T (get dna-frequency \T))
        :G (get dna-frequency \G))
      :C (get dna-frequency \C))))

(sdsu-dna-count "ATGCTTCAGAAAGGTCACG")



;; 6.
(comment "Write a function, sdsu-digits, with two arguments, n and b. The first argument, n, is a non-
negative number in base 10. The second argument, b, is a positive integer also in based
ten. Sdsu-digits converts the first number from base 10 to base b. The return value is a col-
lection of the digits not as one number or as a single string. Digits should be represented
with their integer values. For 15 would be [1 5] in base 10, [1 1 1 1] in base 2 and [15] in
base 16. So for example we have:
(sdsu-digits 12348012 10) returns [1 2 3 4 8 0 1 2]
(sdsu-digits 0 9) returns [0]
(sdsu-digits 140 8) returns [2 1 4]
(sdsu-digits 110 16) returns [6 14")

(defn sdsu-digits
  [n b]
  )



;; 7.
(comment "Write a function sdsu-roman-numeral has one argument, an integer smaller than 4000. The
function returns the corresponding roman numeral in uppercase. See
http://en.wikipedia.org/wiki/Roman_numerals
for information about roman numerals.
(sdsu-roman-numeral 1) returns "I"
(sdsu-roman-numeral 30) returns "XXX"
(sdsu-roman-numeral 4) returns "IV"
(sdsu-roman-numeral 9) returns "IX"
(sdsu-roman-numeral 40) returns "XL"
(sdsu-roman-numeral 90) returns "XC"
(sdsu-roman-numeral 400) returns "CD"
(sdsu-roman-numeral 900) returns "CM"
(sdsu-roman-numeral 1904) returns "MCMIV"")

(defn sdsu-roman-numeral
  [num]
  (let [roman-nums
              {1000 "M"
               900 "CM"
               500 "D"
               400 "CD"
               100 "C"
               90 "XC"
               50 "L"
               40 "XL"
               10 "X"
               9 "IX"
               5 "V"
               4 "IV"
               1 "I"}]
      (loop [roman-decimal [900 500 400 100 90 50 40 10 9 5 4 1]
             s ""
             x 1000
             i num]
        (if (== x 1)
          (end-result s i)
          (if (>= (- i x x x) 0)
            (recur (rest roman-decimal) (str s (get roman-nums x)
                                               (get roman-nums x)
                                               (get roman-nums x)) (first roman-decimal) (- i x x x))
            (if (>= (- i x x) 0)
              (recur (rest roman-decimal) (str s (get roman-nums x)
                                                 (get roman-nums x)) (first roman-decimal) (- i x x))
              (if (>= (- i x) 0)
                (recur (rest roman-decimal) (str s (get roman-nums x)) (first roman-decimal) (- i x))
                (recur (rest roman-decimal) s (first roman-decimal) i))))))))


(defn end-result
  ;; Add any remaining "I" characters to complete the number
  [s i]
  (loop [s s
         i i]
    (if (= i 0)
      s
      (recur (str s "I") (dec i)))))


(sdsu-roman-numeral 1)
